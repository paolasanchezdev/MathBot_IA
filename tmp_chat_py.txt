from typing import Optional, Dict, Any, List, Tuple, Union
import os

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import text as _sql_text

from services.ai import compose_system_prompt, chat_completion
from db import get_db


router = APIRouter()


# Memoria simple en proceso por usuario (solo desarrollo)
_histories: Dict[str, List[Dict[str, str]]] = {}


class ChatRequest(BaseModel):
    user_id: Union[str, int]
    mensaje: str
    # Opcionales para direccionar por Ã­ndices
    unidad: Optional[int] = None
    leccion: Optional[int] = None
    # BÃºsqueda libre: tÃ­tulos, nÃºmeros o palabras clave
    query: Optional[str] = None
    # Solo responder con contenido de BD (si existe)
    solo_bd: Optional[bool] = False
    # CuÃ¡ntos items de contexto devolver como mÃ¡ximo
    max_context: Optional[int] = 1


@router.get("/instructions")
def get_instructions():
    return {"instructions": compose_system_prompt()}


def _has_table(db: Session, table_name: str) -> bool:
    try:
        q = _sql_text(
            """
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = :t
            """
        )
        c = db.execute(q, {"t": table_name}).scalar() or 0
        return int(c) > 0
    except Exception:
        return False


def _norm_lesson_str(s: Optional[str]) -> Optional[str]:
    if not s:
        return s
    try:
        out = str(s).strip()
        out = out.replace(" ", "")
        out = out.replace("/", ".").replace("-", ".").replace(",", ".")
        return out
    except Exception:
        return s


def _build_teoria_from_lessons_row(m: Any) -> Dict[str, Any]:
    unidad = m["unidad"] if hasattr(m, "__getitem__") and "unidad" in m else (m[0] if hasattr(m, "__getitem__") else None)
    leccion = m["leccion"] if hasattr(m, "__getitem__") and "leccion" in m else (m[1] if hasattr(m, "__getitem__") else None)
    titulo = (m["titulo"] if hasattr(m, "__getitem__") and "titulo" in m else ((m[2] if hasattr(m, "__getitem__") else "") or "")) or ""
    objetivo = (m["objetivo"] if hasattr(m, "__getitem__") and "objetivo" in m else ((m[3] if hasattr(m, "__getitem__") else "") or "")) or ""
    teoria = (m["teoria"] if hasattr(m, "__getitem__") and "teoria" in m else ((m[4] if hasattr(m, "__getitem__") else "") or "")) or ""
    formulas = (m["formulas"] if hasattr(m, "__getitem__") and "formulas" in m else ((m[5] if hasattr(m, "__getitem__") else "") or "")) or ""
    actividades = (m["actividades"] if hasattr(m, "__getitem__") and "actividades" in m else ((m[6] if hasattr(m, "__getitem__") else "") or "")) or ""

    partes: List[str] = []
    if objetivo:
        partes.append(f"Objetivo:\n{objetivo}")
    if teoria:
        partes.append(f"Teoria:\n{teoria}")
    if formulas:
        partes.append(f"Formulas clave:\n{formulas}")
    if actividades:
        partes.append(f"Actividades sugeridas:\n{actividades}")

    try:
        unidad_val = int(unidad) if unidad is not None else unidad
    except Exception:
        unidad_val = unidad

    return {
        "unidad": unidad_val,
        "leccion": leccion,
        "titulo": titulo,
        "tema": "",
        "teoria": "\n\n".join(partes).strip(),
    }


def _fetch_teoria_from_db(db: Session, unidad: Optional[int], leccion: Optional[int]) -> Optional[Dict[str, Any]]:
    """Obtiene teorÃ­a desde BD usando el esquema real (l.numero='X.Y', l.nombre).

    Construye 'X.Y' a partir de unidad y leccion si ambos estÃ¡n presentes.
    """
    if unidad is None or leccion is None:
        return None
    lnum = f"{unidad}.{leccion}"
    try:
        # Soporte para tabla 'lessons' (nuevo esquema)
        if _has_table(db, "lessons"):
            lnorm = _norm_lesson_str(lnum)
            row_less = db.execute(
                _sql_text(
                    """
                    SELECT unit_number AS unidad,
                           lesson_number AS leccion,
                           COALESCE(lesson_title,'') AS titulo,
                           COALESCE(objective,'') AS objetivo,
                           COALESCE(theory,'') AS teoria,
                           COALESCE(key_formulas,'') AS formulas,
                           COALESCE(suggested_activities,'') AS actividades
                    FROM lessons
                    WHERE CAST(unit_number AS VARCHAR) = :u
                      AND REPLACE(REPLACE(REPLACE(TRIM(lesson_number),' ',''),'/','.'),'-','.') = :lnum
                    LIMIT 1
                    """
                ),
                {"u": str(unidad), "lnum": lnorm},
            ).first()
            if row_less:
                m_less = row_less._mapping if hasattr(row_less, "_mapping") else None
                return _build_teoria_from_lessons_row(m_less if m_less is not None else row_less)

        row = db.execute(
            _sql_text(
                """
                SELECT u.numero AS unidad,
                       l.numero AS leccion,
                       COALESCE(l.nombre,'') AS titulo,
                       COALESCE(t.titulo,'') AS tema,
                       COALESCE(l.teoria,'') AS teoria
                FROM lecciones l
                JOIN temas t ON l.id_tema = t.id_tema
                JOIN unidades u ON t.id_unidad = u.id_unidad
                WHERE CAST(u.numero AS VARCHAR) = :u AND l.numero = :lnum
                LIMIT 1
                """
            ),
            {"u": str(unidad), "lnum": lnum},
        ).first()
        if not row:
            # Fallback legado: si 'lnum' (unidad.leccion) no coincide con el formato de tu BD,
            # buscar por sufijo de lecciÃ³n dentro de la unidad, sin exigir el prefijo del tema.
            try:
                row = db.execute(
                    _sql_text(
                        """
                        SELECT u.numero AS unidad,
                               l.numero AS leccion,
                               COALESCE(l.nombre,'') AS titulo,
                               COALESCE(t.titulo,'') AS tema,
                               COALESCE(l.teoria,'') AS teoria
                        FROM lecciones l
                        JOIN temas t ON l.id_tema = t.id_tema
                        JOIN unidades u ON t.id_unidad = u.id_unidad
                        WHERE CAST(u.numero AS VARCHAR) = :u
                          AND split_part(l.numero, '.', 2)::int = :lec
                        ORDER BY t.numero::int ASC
                        LIMIT 1
                        """
                    ),
                    {"u": str(unidad), "lec": int(leccion)},
                ).first()
            except Exception:
                row = None
            if not row:
                return None
        m = row._mapping if hasattr(row, "_mapping") else None
        return {
            "unidad": int(m["unidad"]) if m else int(row[0]),
            "leccion": m["leccion"] if m else row[1],
            "titulo": (m["titulo"] if m else row[2]) or "",
            "tema": (m["tema"] if m else row[3]) or "",
            "teoria": (m["teoria"] if m else row[4]) or "",
        }
    except Exception:
        return None


def _fetch_teoria_from_db_by_text(db: Session, unidad: Optional[int], leccion_text: Optional[str]) -> Optional[Dict[str, Any]]:
    """Busca por l.numero='X.Y' en una unidad dada (u.numero), devolviendo la primera coincidencia."""
    if unidad is None or not leccion_text:
        return None
    try:
        # Esquema 'lessons'
        if _has_table(db, "lessons"):
            lnorm = _norm_lesson_str(leccion_text)
            row_less = db.execute(
                _sql_text(
                    """
                    SELECT unit_number AS unidad, lesson_number AS leccion, COALESCE(lesson_title,'') AS titulo,
                           COALESCE(objective,'') AS objetivo, COALESCE(theory,'') AS teoria,
                           COALESCE(key_formulas,'') AS formulas, COALESCE(suggested_activities,'') AS actividades
                    FROM lessons
                    WHERE CAST(unit_number AS VARCHAR) = :u
                      AND REPLACE(REPLACE(REPLACE(TRIM(lesson_number),' ',''),'/','.'),'-','.') = :lnum
                    LIMIT 1
                    """
                ),
                {"u": str(unidad), "lnum": lnorm},
            ).first()
            if row_less:
                m_less = row_less._mapping if hasattr(row_less, "_mapping") else None
                return _build_teoria_from_lessons_row(m_less if m_less is not None else row_less)

        row = db.execute(
            _sql_text(
                """
                SELECT u.numero AS unidad, l.numero AS leccion, COALESCE(l.nombre,'') AS titulo,
                       COALESCE(t.titulo,'') AS tema, COALESCE(l.teoria,'') AS teoria
                FROM lecciones l
                JOIN temas t ON l.id_tema = t.id_tema
                JOIN unidades u ON t.id_unidad = u.id_unidad
                WHERE CAST(u.numero AS VARCHAR) = :u AND l.numero = :lnum
                LIMIT 1
                """
            ),
            {"u": str(unidad), "lnum": leccion_text},
        ).first()
        if not row:
            return None
        m = row._mapping if hasattr(row, "_mapping") else None
        return {
            "unidad": int(m["unidad"]) if m else int(row[0]),
            "leccion": m["leccion"] if m else row[1],
            "titulo": (m["titulo"] if m else row[2]) or "",
            "tema": (m["tema"] if m else row[3]) or "",
            "teoria": (m["teoria"] if m else row[4]) or "",
        }
    except Exception:
        return None


def _parse_leccion_text(q: str) -> Optional[str]:
    """Extrae 'X.Y' de expresiones como 'LecciÃ³n 1.1' y normaliza separadores."""
    import re
    if not q:
        return None
    txt = q.lower()
    m = re.search(r"lecci[oÃ³]n\s+(\d{1,3}(?:[\./-]\d{1,3})?)", txt)
    if not m:
        m = re.search(r"(\d{1,3}[\./-]\d{1,3})", txt)
    if not m:
        return None
    s = m.group(1)
    return s.replace("-", ".").replace("/", ".")


def _fetch_teoria_from_db_by_text_any(db: Session, leccion_text: Optional[str]) -> Optional[Dict[str, Any]]:
    """Busca por l.numero='X.Y' en cualquier unidad y devuelve la primera coincidencia."""
    if not leccion_text:
        return None
    try:
        # Esquema 'lessons'
        if _has_table(db, "lessons"):
            lnorm = _norm_lesson_str(leccion_text)
            row_less = db.execute(
                _sql_text(
                    """
                    SELECT unit_number AS unidad, lesson_number AS leccion, COALESCE(lesson_title,'') AS titulo,
                           COALESCE(objective,'') AS objetivo, COALESCE(theory,'') AS teoria,
                           COALESCE(key_formulas,'') AS formulas, COALESCE(suggested_activities,'') AS actividades
                    FROM lessons
                    WHERE REPLACE(REPLACE(REPLACE(TRIM(lesson_number),' ',''),'/','.'),'-','.') = :lnum
                    ORDER BY unit_number ASC
                    LIMIT 1
                    """
                ),
                {"lnum": lnorm},
            ).first()
            if row_less:
                m_less = row_less._mapping if hasattr(row_less, "_mapping") else None
                return _build_teoria_from_lessons_row(m_less if m_less is not None else row_less)

        row = db.execute(
            _sql_text(
                """
                SELECT u.numero AS unidad, l.numero AS leccion, COALESCE(l.nombre,'') AS titulo,
                       COALESCE(t.titulo,'') AS tema, COALESCE(l.teoria,'') AS teoria
                FROM lecciones l
                JOIN temas t ON l.id_tema = t.id_tema
                JOIN unidades u ON t.id_unidad = u.id_unidad
                WHERE l.numero = :lnum
                ORDER BY u.numero ASC
                LIMIT 1
                """
            ),
            {"lnum": leccion_text},
        ).first()
        if not row:
            return None
        m = row._mapping if hasattr(row, "_mapping") else None
        return {
            "unidad": int(m["unidad"]) if m else int(row[0]),
            "leccion": m["leccion"] if m else row[1],
            "titulo": (m["titulo"] if m else row[2]) or "",
            "tema": (m["tema"] if m else row[3]) or "",
            "teoria": (m["teoria"] if m else row[4]) or "",
        }
    except Exception:
        return None


@router.get("/fetch")
def fetch(unidad: int, leccion: int, db: Session = Depends(get_db)):
    """Endpoint sencillo para depurar: devuelve el contenido crudo de la BD."""
    data = _fetch_teoria_from_db(db, unidad, leccion)
    if not data:
        raise HTTPException(status_code=404, detail="No se encontrÃ³ contenido en BD para esa unidad/lecciÃ³n")
    return data


@router.get("/fetch_text")
def fetch_text(unidad: int, leccion_text: str, db: Session = Depends(get_db)):
    """Como /fetch pero recibe leccion_text='1.1'."""
    data = _fetch_teoria_from_db_by_text(db, unidad, leccion_text)
    if not data:
        raise HTTPException(status_code=404, detail="No se encontrÃ³ contenido en BD para esa unidad/lecciÃ³n")
    return data


def _parse_numbers_from_text(q: str) -> Tuple[Optional[int], Optional[int]]:
    import re
    if not q:
        return None, None
    # Buscar patrones: "Unidad N", "LecciÃ³n L", "N.L", "N/L", "N-L"
    q_low = q.lower()
    uni = None
    lec = None
    m = re.search(r"unidad\s+(\d{1,3})", q_low)
    if m:
        try:
            uni = int(m.group(1))
        except Exception:
            pass
    m = re.search(r"lecci[oÃ³]n\s+(\d{1,3})", q_low)
    if m:
        try:
            lec = int(m.group(1))
        except Exception:
            pass
    m = re.search(r"(\d{1,3})\s*[\./-]\s*(\d{1,3})", q_low)
    if m:
        try:
            uni = int(m.group(1))
            lec = int(m.group(2))
        except Exception:
            pass
    return uni, lec


def _search_lessons_or_legacy(db: Session, query: Optional[str], unidad: Optional[int], leccion: Optional[int], limit: int = 3) -> List[Dict[str, Any]]:
    """BÃºsqueda flexible que prioriza el esquema 'lessons' y cae al esquema legado."""
    results: List[Dict[str, Any]] = []
    try:
        if _has_table(db, "lessons"):
            # Exact match por unidad y lecciÃ³n
            if unidad is not None and leccion is not None:
                lnum = f"{unidad}.{leccion}"
                row_less = db.execute(
                    _sql_text(
                        """
                        SELECT unit_number AS unidad,
                               lesson_number AS leccion,
                               COALESCE(lesson_title,'') AS titulo,
                               COALESCE(objective,'') AS objetivo,
                               COALESCE(theory,'') AS teoria,
                               COALESCE(key_formulas,'') AS formulas,
                               COALESCE(suggested_activities,'') AS actividades
                        FROM lessons
                        WHERE CAST(unit_number AS VARCHAR) = :u AND lesson_number = :lnum
                        LIMIT 1
                        """
                    ),
                    {"u": str(unidad), "lnum": lnum},
                ).first()
                if row_less:
                    m_less = row_less._mapping if hasattr(row_less, "_mapping") else None
                    results.append(_build_teoria_from_lessons_row(m_less if m_less is not None else row_less))
                    if len(results) >= max(1, limit):
                        # dedup y return
                        seen = set()
                        unique: List[Dict[str, Any]] = []
                        for r in results:
                            key = (r.get("unidad"), r.get("leccion"))
                            if key in seen:
                                continue
                            seen.add(key)
                            unique.append(r)
                        return unique[: max(1, limit)]

            has_query = bool(query and query.strip())
            if not has_query and not results:
                return results

            tokens = [t for t in (query or "").strip().split() if len(t) > 1][:6]
            where_clauses = []
            params: Dict[str, Any] = {}
            if unidad is not None:
                where_clauses.append("CAST(unit_number AS VARCHAR) = :wu")
                params["wu"] = str(unidad)
            for i, tok in enumerate(tokens):
                key = f"t{i}"
                params[key] = f"%{tok}%"
                where_clauses.append(
                    f"(lesson_title ILIKE :{key} OR objective ILIKE :{key} OR theory ILIKE :{key} OR key_formulas ILIKE :{key} OR lesson_number ILIKE :{key})"
                )
            where_sql = " AND ".join(where_clauses) if where_clauses else "TRUE"

            rows = db.execute(
                _sql_text(
                    f"""
                    SELECT unit_number AS unidad,
                           lesson_number AS leccion,
                           COALESCE(lesson_title,'') AS titulo,
                           COALESCE(objective,'') AS objetivo,
                           COALESCE(theory,'') AS teoria,
                           COALESCE(key_formulas,'') AS formulas,
                           COALESCE(suggested_activities,'') AS actividades
                    FROM lessons
                    WHERE {where_sql}
                    LIMIT :lim
                    """
                ),
                {**params, "lim": max(1, limit)},
            ).fetchall()
            for row_less in rows:
                m_less = row_less._mapping if hasattr(row_less, "_mapping") else None
                results.append(_build_teoria_from_lessons_row(m_less if m_less is not None else row_less))

            # dedup
            seen = set()
            unique: List[Dict[str, Any]] = []
            for r in results:
                key = (r.get("unidad"), r.get("leccion"))
                if key in seen:
                    continue
                seen.add(key)
                unique.append(r)
            return unique[: max(1, limit)]
    except Exception:
        # si falla, continuar al legado
        pass

    # Fallback al legado
    try:
        return _search_lecciones(db, query, unidad, leccion, limit=limit)
    except Exception:
        return results


# RedefiniciÃ³n mÃ¡s robusta: no sobreescribe la unidad explÃ­cita con el primer nÃºmero del patrÃ³n compuesto N.M
def _parse_numbers_from_text(q: str) -> Tuple[Optional[int], Optional[int]]:
    import re
    if not q:
        return None, None
    q_low = q.lower()
    uni: Optional[int] = None
    lec: Optional[int] = None

    # Unidad explÃ­cita (prioritaria)
    m_uni = re.search(r"unidad\s+(\d{1,3})", q_low)
    if m_uni:
        try:
            uni = int(m_uni.group(1))
        except Exception:
            pass

    # LecciÃ³n explÃ­cita (entera)
    m_lec_int = re.search(r"lecci[oï¿½ï¿½]n\s+(\d{1,3})", q_low)
    if m_lec_int:
        try:
            lec = int(m_lec_int.group(1))
        except Exception:
            pass

    # PatrÃ³n compuesto N.M (o N/M, N-M)
    m_pair = re.search(r"(\d{1,3})\s*[\./-]\s*(\d{1,3})", q_low)
    if m_pair:
        try:
            first = int(m_pair.group(1))
            second = int(m_pair.group(2))
            if uni is None:
                uni = first
            lec = second
        except Exception:
            pass

    return uni, lec

def _search_lecciones(db: Session, query: Optional[str], unidad: Optional[int], leccion: Optional[int], limit: int = 3) -> List[Dict[str, Any]]:
    """BÃºsqueda por texto y filtros usando SQL crudo compatible con el esquema real."""
    results: List[Dict[str, Any]] = []
    try:
        # Exact match si viene unidad y lecciÃ³n
        if unidad is not None and leccion is not None:
            lnum = f"{unidad}.{leccion}"
            row = db.execute(
                _sql_text(
                    """
                    SELECT u.numero AS unidad, l.numero AS leccion,
                           COALESCE(l.nombre,'') AS titulo,
                           COALESCE(t.titulo,'') AS tema,
                           COALESCE(l.teoria,'') AS teoria
                    FROM lecciones l
                    JOIN temas t ON l.id_tema = t.id_tema
                    JOIN unidades u ON t.id_unidad = u.id_unidad
                    WHERE CAST(u.numero AS VARCHAR) = :u AND l.numero = :lnum
                    LIMIT 1
                    """
                ),
                {"u": str(unidad), "lnum": lnum},
            ).first()
            if row:
                m = row._mapping if hasattr(row, "_mapping") else None
                results.append({
                    "unidad": int(m["unidad"]) if m else int(row[0]),
                    "leccion": m["leccion"] if m else row[1],
                    "titulo": (m["titulo"] if m else row[2]) or "",
                    "tema": (m["tema"] if m else row[3]) or "",
                    "teoria": (m["teoria"] if m else row[4]) or "",
                })
                if len(results) >= max(1, limit):
                    return results

        has_query = bool(query and query.strip())
        if not has_query and not results:
            return results

        tokens = [t for t in (query or "").strip().split() if len(t) > 1][:6]
        where_clauses = []
        params: Dict[str, Any] = {}
        if unidad is not None:
            where_clauses.append("CAST(u.numero AS VARCHAR) = :wu")
            params["wu"] = str(unidad)
            for i, tok in enumerate(tokens):
                key = f"t{i}"
                params[key] = f"%{tok}%"
                where_clauses.append(
                    f"(l.nombre ILIKE :{key} OR t.titulo ILIKE :{key} OR u.titulo ILIKE :{key} OR l.teoria ILIKE :{key} OR l.numero ILIKE :{key})"
                )
        where_sql = " AND ".join(where_clauses) if where_clauses else "TRUE"

        rows = db.execute(
            _sql_text(
                f"""
                SELECT u.numero AS unidad, l.numero AS leccion,
                       COALESCE(l.nombre,'') AS titulo,
                       COALESCE(t.titulo,'') AS tema,
                       COALESCE(l.teoria,'') AS teoria
                FROM lecciones l
                JOIN temas t ON l.id_tema = t.id_tema
                JOIN unidades u ON t.id_unidad = u.id_unidad
                WHERE {where_sql}
                LIMIT :lim
                """
            ),
            {**params, "lim": max(1, limit)},
        ).fetchall()
        for row in rows:
            m = row._mapping if hasattr(row, "_mapping") else None
            results.append({
                "unidad": int(m["unidad"]) if m else int(row[0]),
                "leccion": m["leccion"] if m else row[1],
                "titulo": (m["titulo"] if m else row[2]) or "",
                "tema": (m["tema"] if m else row[3]) or "",
                "teoria": (m["teoria"] if m else row[4]) or "",
            })

        # Evitar duplicados
        seen = set()
        unique: List[Dict[str, Any]] = []
        for r in results:
            key = (r.get("unidad"), r.get("leccion"))
            if key in seen:
                continue
            seen.add(key)
            unique.append(r)
        return unique[: max(1, limit)]
    except Exception:
        return results


@router.post("/send")
def chat_send(data: ChatRequest, db: Session = Depends(get_db)):
    try:
        # Validar usuario si estÃ¡ activado
        if os.getenv("CHAT_REQUIRE_KNOWN_USER", "false").lower() in {"1", "true", "yes"}:
            try:
                from utils.users_reflect import get_user_by_id
                exists = get_user_by_id(db, data.user_id)
                if not exists:
                    try:
                        exists = get_user_by_id(db, int(data.user_id))
                    except Exception:
                        exists = None
                if not exists:
                    raise HTTPException(status_code=404, detail="Usuario no encontrado")
            except HTTPException:
                raise
            except Exception:
                # Si no se puede reflejar, no bloqueamos el chat
                pass

        # Historial del usuario
        uid = str(data.user_id)
        hist = _histories.setdefault(uid, [])

        # ConstrucciÃ³n de mensajes
        system_msg = {"role": "system", "content": compose_system_prompt()}

        # Resolver contexto: por unidad/lecciÃ³n o por query/palabras clave
        context_items: List[Dict[str, Any]] = []
        exact = _fetch_teoria_from_db(db, data.unidad, data.leccion)
        # Fallback: intentar parsear unidad/lecciÃ³n desde el texto del mensaje
        if (not exact) and data.mensaje:
            m_uni, m_lec = _parse_numbers_from_text(data.mensaje)
            if (m_uni is not None) or (m_lec is not None):
                exact = _fetch_teoria_from_db(db, m_uni, m_lec)
            # Si no se encontrÃ³, intentar con lecciÃ³n textual del tipo '1.1'
            if not exact:
                ltxt = _parse_leccion_text(data.mensaje)
                if ltxt and (m_uni is not None or data.unidad is not None):
                    _unit = m_uni if m_uni is not None else data.unidad
                    # Intento directo con el texto detectado (p. ej., '1.3')
                    exact = _fetch_teoria_from_db_by_text(db, _unit, ltxt)
                    # Si no coincide, y el prefijo de ltxt no coincide con la unidad explÃ­cita, prueba N.B
                    if (not exact) and ("." in ltxt):
                        try:
                            _a, _b = ltxt.split(".", 1)
                            alt = f"{_unit}.{_b.strip()}"
                            exact = _fetch_teoria_from_db_by_text(db, _unit, alt)
                        except Exception:
                            pass
        # Fallback adicional: si aÃºn no se encontrÃ³, intentar por 'X.Y' en cualquier unidad
        if (not exact) and data.mensaje:
            _ltxt = _parse_leccion_text(data.mensaje)
            if _ltxt:
                _any = _fetch_teoria_from_db_by_text_any(db, _ltxt)
                if _any:
                    exact = _any
        if exact:
            context_items.append(exact)
        # Si no hay coincidencia exacta, buscar por texto usando query o el propio mensaje
        if (not exact):
            search_text = (data.query or data.mensaje or "").strip()
            if search_text:
                context_items.extend(
                    _search_lessons_or_legacy(
                        db,
                        search_text,
                        data.unidad,
                        data.leccion,
                        limit=max(1, data.max_context or 1),
                    )
                )

        # Unir contexto en texto compacto
        def fmt_item(it: Dict[str, Any]) -> str:
            titulo = it.get("titulo") or ""
            tema = it.get("tema") or ""
            unidad = it.get("unidad")
            leccion = it.get("leccion")
            cuerpo = (it.get("teoria") or "").strip()
            cuerpo = cuerpo[:1500]  # limitar tamaÃ±o
            encabezado = f"Unidad {unidad} - LecciÃ³n {leccion}: {titulo} (Tema: {tema})"
            # Reforzar encabezado ASCII independientemente de codificaciones
            encabezado = f"Unidad {unidad} - Leccion {leccion}: {titulo} (Tema: {tema})"
            return encabezado + "\n" + cuerpo

        contexto_txt = "\n\n---\n\n".join(fmt_item(x) for x in context_items) if context_items else ""

        if data.solo_bd:
            # En modo solo_bd devolvemos el contenido de BD como prompt para la IA (o directamente, si quisieras)
            user_msg = {"role": "user", "content": (contexto_txt or "Sin contenido en BD.").strip()}
            messages = [system_msg] + hist + [user_msg]
        else:
            # Priorizar BD: inyectar el contexto como mensaje 'system' adicional
            user_msg = {"role": "user", "content": f"Pregunta: {data.mensaje}"}
            if contexto_txt.strip():
                db_context_msg = {
                    "role": "system",
                    "content": (
                        "Usa estrictamente el siguiente contexto de BD como base; no lo contradigas. "
                        "Luego, complementa con explicaciones claras y ejemplos cuando aporte valor.\n\n"
                        f"Contexto de BD:\n{contexto_txt}"
                    ),
                }
                messages = [system_msg, db_context_msg] + hist + [user_msg]
            else:
                messages = [system_msg] + hist + [user_msg]

        ai_text = chat_completion(messages)

        # Actualizamos historial
        hist.append({"role": "user", "content": data.mensaje})
        hist.append({"role": "assistant", "content": ai_text})

        # Datos de depuraciÃ³n bÃ¡sicos para verificar el parseo del mensaje
        dbg_ltxt = _parse_leccion_text(data.mensaje or "") if data.mensaje else None
        dbg_uni, dbg_lec = _parse_numbers_from_text(data.mensaje or "") if data.mensaje else (None, None)

        return {
            "respuesta": ai_text,
            "usando_contexto": bool(context_items),
            "contexto_items": [
                {"unidad": it.get("unidad"), "leccion": it.get("leccion"), "titulo": it.get("titulo")}
                for it in context_items
            ],
            "debug": {
                "context_count": len(context_items),
                "ltxt": dbg_ltxt,
                "p_uni": dbg_uni,
                "p_lec": dbg_lec,
            },
        }
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chat error: {e}")


@router.get("/search")
def search(query: str, limit: int = 5, db: Session = Depends(get_db)):
    try:
        items = _search_lessons_or_legacy(db, query, None, None, limit=limit)
        # Reducir payload
        out = [
            {
                "unidad": it.get("unidad"),
                "leccion": it.get("leccion"),
                "titulo": it.get("titulo"),
                "tema": it.get("tema"),
                "preview": (it.get("teoria") or "")[:200],
            }
            for it in items
        ]
        return {"count": len(out), "items": out}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Search error: {e}")


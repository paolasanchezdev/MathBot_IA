// modules/consola.js
import { getState, loadState, setCurrentChat, getChats } from "./storage.js";
import { renderChatList, renderMessage, renderChatOutput, updateChatTitle, showTypingIndicator, hideTypingIndicator, initScrollToBottom } from "./ui.js";
import { addChat, sendMessage, clearMessages } from "./chat.js";
import { sendQuestion } from "./network.js";
import { initThemeToggle, scrollToBottom, updateStatus } from "./utils.js";

const inputEl = document.getElementById("console-command");
const sendBtn = document.getElementById("send-btn");
const newChatBtn = document.getElementById("new-chat-btn");
const chatListEl = document.getElementById("chat-list");
const outputEl = document.getElementById("console-output");
const dashboardBtn = document.getElementById("btn-dashboard");
const searchInput = document.getElementById("chat-search");
const clearBtn = document.getElementById("clear-chat-btn");

dashboardBtn.addEventListener("click", () => {
  // Redirige al dashboard principal
  window.location.href = "../dashboard/dashboard.html"; 
});


// ==============================
// Enviar mensaje
// ==============================
async function handleSendMessage() {
  const question = inputEl.value.trim();
  if (!question || !getState().currentChat) return;

  const currentId = getState().currentChat.id;

  // Guardar mensaje del usuario
  sendMessage(currentId, { sender: "user", text: question });
  renderMessage({ sender: "user", text: question });

  inputEl.value = "";
  try { inputEl.style.height = 'auto'; } catch {}
  inputEl.focus();

  // Mostrar indicador de escritura del bot
  showTypingIndicator();

  // Enviar al backend
  try {
    await sendQuestion(question); // Esta función debe agregar el mensaje del bot al chat
  } catch (err) {
    sendMessage(currentId, { sender: "ai", text: "Error: no se pudo conectar con el servidor." });
    renderMessage({ sender: "ai", text: "Error: no se pudo conectar con el servidor." });
    updateStatus("Desconectado", false);
  }

  hideTypingIndicator();
}

// ==============================
// Nuevo chat
// ==============================
function handleNewChat() {
  const name = prompt("Nombre del nuevo chat:");
  if (!name) return;

  const id = addChat(name);
  setCurrentChat(id);
  renderChatList(getChats());
  updateChatTitle(name);

  inputEl.disabled = false;
  sendBtn.disabled = false;
  inputEl.focus();
  // Renderizar de inmediato (muestra el mensaje de bienvenida)
  renderChatOutput(getState().currentChat);
}

// ==============================
// Seleccionar chat desde la lista
// ==============================
function handleChatSelection(e) {
  const li = e.target.closest("li");
  if (!li || !li.dataset.id) return;

  const chatId = li.dataset.id;
  setCurrentChat(chatId);

  renderChatList(getChats());
  updateChatTitle(getState().currentChat.name);

  // Renderizar mensajes del chat seleccionado
  outputEl.innerHTML = ""; // Limpiar solo al cambiar de chat
  const chat = getState().currentChat;
  if (chat && chat.messages.length) {
    chat.messages.forEach(msg => renderMessage(msg));
  }
}

// ==============================
// Inicialización
// ==============================
function init() {
  loadState();
  const { chats, currentChat } = getState();

  // Si no hay chats, crear uno de ejemplo
  if (chats.length === 0) {
    const id = addChat("Chat de ejemplo");
    setCurrentChat(id);
  } else if (currentChat) {
    setCurrentChat(currentChat.id);
  }

  renderChatList(getChats());
  updateChatTitle(getState().currentChat?.name || null);

  // Renderizar mensajes del chat actual
  const chat = getState().currentChat;
  if (chat && chat.messages.length) {
    chat.messages.forEach(msg => renderMessage(msg));
  }

  updateStatus("Conectado", true);

  // Habilitar inputs
  inputEl.disabled = false;
  sendBtn.disabled = false;
  try { inputEl.style.height = 'auto'; } catch {}

  // Eventos
  sendBtn.addEventListener("click", handleSendMessage);
  // Enviar con Enter, salto de línea con Shift+Enter (estilo ChatGPT)
  inputEl.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  });
  // Auto-resize del textarea
  const autoResize = () => {
    try {
      inputEl.style.height = 'auto';
      const max = 220; // altura máxima similar a ChatGPT
      inputEl.style.height = Math.min(inputEl.scrollHeight, max) + 'px';
    } catch {}
  };
  inputEl.addEventListener('input', autoResize);
  newChatBtn.addEventListener("click", handleNewChat);
  // Sugerencias (chips) en estado vacío
  document.querySelectorAll('.suggestions .chip').forEach(chip => {
    chip.addEventListener('click', () => {
      const t = chip.getAttribute('data-text') || chip.textContent;
      inputEl.value = t;
      inputEl.disabled = false;
      sendBtn.disabled = false;
      try { inputEl.style.height = 'auto'; } catch {}
      inputEl.focus();
    });
  });
  // Filtro de chats
  if (searchInput) {
    const doFilter = () => {
      const q = (searchInput.value || '').toLowerCase();
      const src = getChats();
      const filtered = q
        ? src.filter(c => (c.name||'').toLowerCase().includes(q) || (c.messages?.[c.messages.length-1]?.text||'').toLowerCase().includes(q))
        : src;
      renderChatList(filtered);
    };
    searchInput.addEventListener('input', doFilter);
  }
  // Limpiar chat actual
  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      const current = getState().currentChat;
      if (!current) return;
      if ( !confirm(¿Limpiar todos los mensajes de este chat?)) return; 
      clearMessages(current.id);
      renderChatList(getChats());
      renderChatOutput(getState().currentChat);
    });
  }

  // Evento para cambiar de chat haciendo click en la lista
  chatListEl.addEventListener("click", handleChatSelection);

  initThemeToggle();
  initScrollToBottom();
}

// Inicializar la consola
init();




